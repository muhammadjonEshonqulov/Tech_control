import 'package:easy_localization/easy_localization.dart';import 'package:http/http.dart' as http;import 'package:tech_control/utils/utils.dart';import '../data/database/cache.dart';import 'network_result.dart';class ApiHelper {  static const String baseUrl = 'https://techniques-back.vercel.app/';  final http.Client client = http.Client();  Future<NetworkResult<Map<String, dynamic>>> myGet(String endPoint, Map<String, dynamic> params) async {    var has = await checkNetwork();    if (!has) {      return Error(message: "connection_error_message".tr(), data: null, code: 0);    }    final url = Uri.parse(baseUrl + endPoint);    Map<String, String> stringParams = Map<String, String>.from(params.map((key, value) => MapEntry(key, value.toString())));    final Uri fullUrl = Uri.https(url.host, url.path, stringParams);    var token = await cache.getString(cache.token);    final headers = {      'Content-Type': 'application/json',      'Accept': 'application/json',      'Authorization': 'Bearer ${token}',    };    final response = await http.get(fullUrl, headers: headers);    try {      return handleResponse(response);    } catch (e) {      return catchErrors(e);    }  }  Future<NetworkResult<Map<String, dynamic>>> myPost<T>(String endPoint, T body) async {    var has = await checkNetwork();    if (!has) {      return Error(message: "connection_error_message".tr(), data: null, code: 0);    }    final url = Uri.parse(baseUrl + endPoint);    final Uri fullUrl = Uri.https(url.host, url.path);    var token = await cache.getString(cache.token);    final headers = {      'Content-Type': 'application/json',      'Accept': 'application/json',      'Authorization': 'Bearer ${token}',    };    final response = await http.post(fullUrl, headers: headers, body: body);    try {      return handleResponse(response);    } catch (e) {      return catchErrors(e);    }  }  Future<NetworkResult<Map<String, dynamic>>> myPatch<T>(String endPoint, T body) async {    var has = await checkNetwork();    if (!has) {      return Error(message: "connection_error_message".tr(), data: null, code: 0);    }    final url = Uri.parse(baseUrl + endPoint);    final Uri fullUrl = Uri.https(url.host, url.path);    var token = await cache.getString(cache.token);    final headers = {      'Content-Type': 'application/json',      'Accept': 'application/json',      'Authorization': 'Bearer ${token}',    };    final response = await http.patch(fullUrl, headers: headers, body: body);    kprint(response.body);    kprint(headers);    kprint(fullUrl);    kprint(body);    try {      return handleResponse(response);    } catch (e) {      return catchErrors(e);    }  }}